//*****************************************************************************
//            VISUALIZACION COMPUTACIONAL 1 - TP Nº2 - 2012
//                      Carolina Valdez Gándara
//*****************************************************************************


import java.awt.*;
import java.awt.image.BufferedImage;
import java.lang.reflect.InvocationTargetException;
import java.util.Vector;
import javax.swing.JOptionPane;
import java.lang.reflect.Method;
import java.util.logging.Level;
import java.util.logging.Logger;


/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Caro
 */
public class Principal extends javax.swing.JFrame {
   
    //*********************************************************************
   //Declaración de variables a utilizar
  //***********************************************************************
    Paleta P; // es la paleta por defecto
    Paleta Pactual; // es la paleta actual que cambiará entre las paletas existentes
    BufferedImage b,bref; 
    Graphics g,g2,gref;
    //Defino las variables de rango real e imaginario
    double minR;// = -1.5;
    double maxR;// = 0.5;
    double minI;// = -1.0;
    double maxI;// = 1.0;
    //las siguientes 4 variables son para controlar el "agrandado" de imagen mediante zoom
    double minRnuevo;
    double maxRnuevo;
    double minInuevo;
    double maxInuevo;
    //****************************
    int mat_datos[][]; //Matriz de respaldo para evitar rehacer los calculos cuando hay que repintar con otra paleta
    int mat_datos_actual[][];//Al igual que con la paleta, llevo una referencia a la matriz de datos actual 
                             //para cuando se cambia de tipo de fractal y se quiere repintar con otra paleta
    int max_x;
    int max_y;
    
    int inicio_x; //variables para alterar los valores R e I para mover en x y en y la imagen zoomeada.
    int inicio_y;
    int fin_x;
    int fin_y;
    
    int mouse_clickeado;//Variable para controlar cuando seleccionar area para hacer zoom
    boolean fractal_calculado; //Si no se calculó ningún fractal no se podrá cambiar la paleta
    boolean hubo_dragueo; //variable para controlar que cuando se haga un clic no se calcule el fractal
    String fractal_elegido;//Variable a utilizar cuando se elije un tipo de fractal en el comboBox antes de presionar el boton
    Rectangle referencia;
    
    /**
     * Creates new form Principal
     */
   
    //Aqui se inicializan las variables de clase
    public Principal() {
        initComponents();
        
        P = new Paleta (1); // 1 = paleta por defecto, 2 = paleta No Signal, 3 = paleta Fire, 4 = paleta Blue Steel
        Pactual = P;
        max_x = jPanel1.getWidth();//Maximos del panel en el que se va a pintar el fractal
        max_y = jPanel1.getHeight();
       
        g = jPanel1.getGraphics();
        mat_datos= new int [max_x][max_y];//Esta estructura almacena los datos calculados 
                                         //para hacer mas rapido el repintado cuando se cambia de paleta
        fractal_calculado = false;
        hubo_dragueo = false;
        fractal_elegido = null; //Segun la eleccion en el jComboBox2 se ejecutará el método calcularFractal+fractal_elegido
        Method method;
        minR = -1.5;
        maxR = 0.5;
        minI = -1.0;
        maxI = 1.0;
        mouse_clickeado = 0;
        
    }
    
   
    
    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jComboBox1 = new javax.swing.JComboBox();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jComboBox2 = new javax.swing.JComboBox();
        jProgressBar1 = new javax.swing.JProgressBar();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu2 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Visualización Computacional I - TP 2");
        setResizable(false);
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        jPanel1.setPreferredSize(new java.awt.Dimension(600, 450));
        jPanel1.addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                jPanel1MouseWheelMoved(evt);
            }
        });
        jPanel1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                jPanel1MousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                jPanel1MouseReleased(evt);
            }
        });
        jPanel1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                jPanel1MouseDragged(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 439, Short.MAX_VALUE)
        );

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Por defecto", "No Signal", "Fire", "Blue Steel" }));
        jComboBox1.setSelectedItem(null);
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jButton1.setText("Cargar Fractal");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setText("Paletas");

        jLabel2.setText("  Fractales");

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Mandelbrot", "Manowar", "Spider", "Carolina" }));
        jComboBox2.setSelectedItem(null);
        jComboBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox2ActionPerformed(evt);
            }
        });

        jProgressBar1.setInheritsPopupMenu(true);

        jMenu2.setText("Archivo");

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F1, 0));
        jMenuItem1.setText("Ayuda");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem1);

        jMenuItem2.setText("Acerca de");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem2);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(86, 86, 86)
                        .addComponent(jButton1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(33, 33, 33)
                                .addComponent(jLabel1)))
                        .addGap(22, 22, 22)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(37, 37, 37))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(63, 63, 63)
                        .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(13, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, 439, 439, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1)
                        .addGap(18, 18, 18)
                        .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(16, 16, 16)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(23, Short.MAX_VALUE))
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents
//*****************************************************************************
//La siguiente función se dispara cuando se selecciona una paleta del combo box,
//siempre y cuando, el fractal ya esté cargado y pueda repintarse.
//Luego de seleccionada la paleta a utilizar, se repinta el fractal usando la matriz de datos
//para no perder tiempo en recalcular el fractal.    
//*****************************************************************************

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        if (!jButton1.isEnabled())
        {
            String selec_paleta="";
            if (evt.getSource() == jComboBox1)
               {  
                   selec_paleta = (String)jComboBox1.getSelectedItem();
                   if (selec_paleta.equals("No Signal"))
                       Pactual = new Paleta (2);
                   else
                       if (selec_paleta.equals("Fire"))
                           Pactual = new Paleta (3);
                       else
                           if (selec_paleta.equals("Blue Steel"))
                               Pactual = new Paleta (4);
                           else 
                               Pactual=P;
             mat_datos_actual = mat_datos;
             this.repintarFractal();  
             
                }
        }
        else
           { 
               JOptionPane.showMessageDialog(null,"Aun no ha generado ningún fractal","Error",JOptionPane.ERROR_MESSAGE);
               jComboBox1.setSelectedItem(null);
           }
   
    }//GEN-LAST:event_jComboBox1ActionPerformed

//*****************************************************************************
//La siguiente funcion se dispara cuando se hace clic en el botón "cargar fractal"
//La paleta actual hace referencia a la paleta por defecto, se genera el fractal, se pinta, 
//y se almacenan los cálculos en la matriz "mat_datos". Luego, el botón se deshabilita 
//para evitar que se rehagan los cálculos y se pierda tiempo de carga de la imagen.   
//NOTA: se construye el nombre de la funcion a ejecutar con un string = "generarFractal"+fractal elegido en el comboBox
//Para ejecutar la funcion que se corresponde con el valor del string "nombre_de_funcion" se usa la funcionalidad
//de Java "Reflection", que permite al usuario manipular clases e interfaces en tiempo de ejecución     
//***************************************************************************** 
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        Paleta Pactual=P;
        b= new BufferedImage(jPanel1.getWidth(), jPanel1.getHeight(), BufferedImage.TYPE_INT_RGB);
    
        String nombre_de_funcion;
        if (jButton1.isEnabled() && (jComboBox2.getSelectedItem()==null))
            {
                fractal_elegido = "Mandelbrot";
                jButton1.setEnabled(false);
            }
        
        nombre_de_funcion = "generarFractal"+fractal_elegido;
        seleccionarFractal (nombre_de_funcion);
      
         fractal_calculado = true;    
         jButton1.setEnabled(false);
    }//GEN-LAST:event_jButton1ActionPerformed
//****************************************************************************
//El siguiente metodo se dispara cuando se selecciona un item del comboBox2, para elegir tipo de fractal
//Utiliza el mismo mecanismo que en el evento disparado por el botón. Si el botón ya fue presionado, por ende
//deshabilitado, al hacer clic sobre alguno de los items se repintará el fractal seleccionado.
//*****************************************************************************
    private void jComboBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox2ActionPerformed
        
        
           if (evt.getSource()==jComboBox2)
            { 
               
                fractal_elegido = jComboBox2.getSelectedItem().toString(); //la opcion elegida en el comboBox2
                System.out.println(fractal_elegido); 
            }
           if (!jButton1.isEnabled())
             {
                 restaurarValoresOriginales(); // si he modificado maxRorig,minRorig, maxIorig, minIorig al hacer zoom,
                                              // vuelvo a setear sus valores originales
                 String nombre_de_funcion = "generarFractal"+fractal_elegido; 
                 seleccionarFractal(nombre_de_funcion);
             }          
    }//GEN-LAST:event_jComboBox2ActionPerformed

//****************************************************************************
//La siguiente funcion acerca la imagen un 10% o la aleja un 10%, dependiendo si se mueve la ruedita del mouse
//hacia arriba o hacia abajo respectivamente.
//****************************************************************************
    private void jPanel1MouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_jPanel1MouseWheelMoved
        if (fractal_calculado)
        {  
               int vuelta =-evt.getWheelRotation();
               //Altero las variables reales e imaginarias para obtener la imagen con zoom de un 10% de la imagen
                minRnuevo = minR + (maxR - minR) * 0.1 * vuelta;
                maxRnuevo = maxR - (maxR - minR) * 0.1 * vuelta;
                minInuevo = minI + (maxI - minI) * 0.1 * vuelta;
                maxInuevo = maxI - (maxI - minI) * 0.1 * vuelta;
                maxR = maxRnuevo;
                minR = minRnuevo;
                maxI = maxInuevo;
                minI = minInuevo;
                System.out.println("minR: "+minR);
                System.out.println("maxR: "+maxR);
                System.out.println("minI: "+minI);
                System.out.println("maxI: "+maxI);
                String nombre_de_funcion = "generarFractal"+fractal_elegido;
                seleccionarFractal (nombre_de_funcion);
                repaint();
          
        }  
       
    }//GEN-LAST:event_jPanel1MouseWheelMoved
//****************************************************************************
//La siguiente funcion se ejecuta cuando se suelta el boton del mouse luego de efectuar el dragueo correspondiente
//a mover el fractal hacia arriba, abajo, izquierda o derecha.    
//****************************************************************************    
    private void jPanel1MouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseReleased
        if (fractal_calculado && hubo_dragueo)
        {
         java.awt.Point punto_final = evt.getPoint();
         double x = punto_final.getX() - inicio_x;
         double y = punto_final.getY() - inicio_y;
         double diferencia_real = (maxR - minR) / max_x;
         double diferencia_imaginaria = (maxI - minI) /max_y;
         maxR -= diferencia_real *x;
         minR -= diferencia_real *x;
         maxI -= diferencia_imaginaria * y;
         minI -= diferencia_imaginaria * y;
         System.out.println("minR: "+minR);
         System.out.println("maxR: "+maxR);
         System.out.println("minI: "+minI);
         System.out.println("maxI: "+maxI);
         String nombre_de_funcion = "generarFractal"+fractal_elegido;
         seleccionarFractal (nombre_de_funcion);
         hubo_dragueo = false;
         repaint();
        }
    }//GEN-LAST:event_jPanel1MouseReleased
//****************************************************************************
//La siguiente funcion toma el valor inicial de desplazamiento de x y de y al presionar el boton principal del mouse.
//****************************************************************************   
    private void jPanel1MousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MousePressed
         if (fractal_calculado)
         { 
            inicio_x = evt.getX();      
            inicio_y = evt.getY();
            System.out.println(inicio_x);     
         }
    }//GEN-LAST:event_jPanel1MousePressed

    
//La siguiente funcion se ejecuta cuando se presiona la opción "acerca de" en el menu "archivo"
//se dispara una nueva ventana que muestra la información solicitada    
    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
         AcercaDe dialogo = new AcercaDe();
         dialogo.setVisible(true);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    
//La siguente función se ejecuta cuando se presiona la opcion "Ayuda" del menú "archivo"   
    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        Ayuda ventana_ayuda = new Ayuda();
        ventana_ayuda.setVisible(true);
        
    }//GEN-LAST:event_jMenuItem1ActionPerformed

//La siguiente función controla solamente si hubo dragueo o no. De esta forma si se hace clic en el panel
//y no se draguea no se recalculará ningun fractal.    
    private void jPanel1MouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPanel1MouseDragged
        hubo_dragueo = true;
    }//GEN-LAST:event_jPanel1MouseDragged

//Si se presiona la tecla F1 se muestra la ventana de ayuda.
    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
       if(evt.getKeyCode() == evt.VK_F1)
       {
           Ayuda a = new Ayuda();
           a.setVisible(true);
       }
       
    }//GEN-LAST:event_formKeyPressed

//*****************************************************************************
//                         METODO MAIN
//*****************************************************************************

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new Principal().setVisible(true);
                
            }
        });
    }
    
 //*****************************************************************************
//                         FIN METODO MAIN
//*****************************************************************************

    
//*****************************************************************************
//             CODIGO AUTOMATICO DE LAS VARIABLES SWING UTILIZADAS
//*****************************************************************************

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JProgressBar jProgressBar1;
    // End of variables declaration//GEN-END:variables
//*****************************************************************************
//            FIN CODIGO AUTOMATICO DE LAS VARIABLES SWING UTILIZADAS
//*****************************************************************************

    
    
//*****************************************************************************
//                        FUNCIONES PARA RESOLVER EL TP
//*****************************************************************************
   
  public void seleccionarFractal(String nombre_de_funcion)
  {
      hubo_dragueo=false;
      try {
                  Method method = this.getClass().getMethod(nombre_de_funcion, null);
                  try {
                                method.invoke(this, null);
                              } catch (IllegalAccessException ex) {
                                Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                                       } catch (IllegalArgumentException ex) {
                                               Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                                               } catch (InvocationTargetException ex) {
                                                       Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                                                     }
                  
                  } catch (NoSuchMethodException ex) {
                        Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                        } catch (SecurityException ex) {
                             Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
                             }    
              
         g.drawImage(b,0,0,rootPane);
  }
    
    
    
    
    
 //*****************************************************************************
//La siguiente función calcula el color dentro del rango correspondiente al parámetro recibido
//(resultado del cálculo del fractal). Para esto calcula el degradé entre el color del rango anterior
//y el rango al que pertenece el valor.    
//*****************************************************************************
   public Color getColor(int dato) 
    {
        Vector <Color> colores = Pactual.getListaDeColores();
        Vector <Integer> escala = Pactual.getListaDeValores();
        Color nuevo;
        for (int i = 0; i < colores.size(); i++) 
        {
            if (dato <= escala.elementAt(i))
		if (i == 0)
		   return colores.elementAt(i);
		else 
                   {
		      int R1 = colores.elementAt(i - 1).getRed();
		      int G1 = colores.elementAt(i - 1).getGreen();
		      int B1 = colores.elementAt(i - 1).getBlue();
                      int R2 = colores.elementAt(i).getRed();
		      int G2 = colores.elementAt(i).getGreen();
		      int B2 = colores.elementAt(i).getBlue();
                      int rango = (escala.elementAt(i) - escala.elementAt(i - 1));
		      int dif = dato - escala.elementAt(i - 1);
                      int R = ((R1 * (rango - dif)) + (R2 * dif))/ rango;
		      int G = ((G1 * (rango - dif)) + (G2 * dif))/ rango;
		      int B = ((B1 * (rango - dif)) + (B2 * dif))/ rango;
                      nuevo = new Color(R,G,B);
		      return nuevo;
		   }

	}
	return colores.elementAt(colores.size()-1);
     }
    
//*****************************************************************************
//  La siguiente función realiza el cálculo del fractal tipo Mandelbrot
//*****************************************************************************
    public int counterMandelbrot(int pos_x, int pos_y)
    {
           
        int iteraciones = 0;
        double r = (pos_x)*(maxR-minR)/max_x + minR;
        double i = (pos_y)*(maxI-minI)/max_y + minI;
        
        NroComplejo Zn = new NroComplejo (0.0,0.0);
        NroComplejo Z0 = new NroComplejo(r,i);
        NroComplejo aux = new NroComplejo(0.0,0.0);
        double modulo = Zn.getModulo();
        while ((iteraciones < 256) && (modulo <4))
          {
            aux = Zn.sqrt();
            Zn = NroComplejo.sumar(aux, Z0);          
            modulo = Zn.getModulo();
            iteraciones++;
          }
        return iteraciones;
    
    }
    
    
    public void generarFractalMandelbrot() {
        
        int dato;
        b = new BufferedImage(max_x,max_y, BufferedImage.TYPE_INT_RGB); 
        jProgressBar1.setValue(0);
        jProgressBar1.setMinimum(0);
        jProgressBar1.setMaximum(max_x);
        for (int x = 0; x < max_x ; x++)
        {  
            for (int y = 0 ; y < max_y ; y++)
            {
                dato = this.counterMandelbrot(x,y);
                mat_datos[x][y] = dato; //Guardo los datos en una matriz para hacer eficiente el repintado cuando se cambia de paleta
                Color nuevo_color = this.getColor(dato);
                b.setRGB(x,y,nuevo_color.getRGB());
            }
        jProgressBar1.setValue(x);
        jProgressBar1.update(jProgressBar1.getGraphics());
        }
    }
 
//*********************************************************************************************
//  La siguiente función realiza los calculos para el fractal tipo Manowar
//*********************************************************************************************    
    public int counterManowar(int pos_x,int pos_y)
    {
        double r = (pos_x)*(maxR-minR)/max_x + minR;
        double i = (pos_y)*(maxI-minI)/max_y + minI;
        double modulo;  
        int iteraciones = 0;
        NroComplejo c = new NroComplejo(r,i);
        NroComplejo Z1 = new NroComplejo(r,i);
        NroComplejo Zn = new NroComplejo(r,i);
        NroComplejo Zanterior = new NroComplejo(0,0);
        NroComplejo aux = new NroComplejo(0,0); 
        modulo = Zn.getModulo();
        while((iteraciones <256) && (modulo < 4))
            {
                aux = Zn.sqrt();
                Zn = NroComplejo.sumar(NroComplejo.sumar(aux,Z1),c);
                Z1 = Zanterior;
                Zanterior = Zn;
                modulo = Zn.getModulo();
                iteraciones++;
            }
        return iteraciones;
  
}
    
    
public void generarFractalManowar()
{
    int dato;
    Color nuevo;
    b = new BufferedImage(max_x,max_y, BufferedImage.TYPE_INT_RGB); 
    jProgressBar1.setValue(0);
    jProgressBar1.setMinimum(0);
    jProgressBar1.setMaximum(max_x);
    for (int x = 0; x < max_x ; x++)
    {
        for (int y = 0 ; y < max_y ; y++)
       {
           dato = counterManowar(x,y);
           mat_datos[x][y] = dato;
           b.setRGB(x,y,this.getColor(dato).getRGB());
       }
       jProgressBar1.setValue(x);
       jProgressBar1.update(jProgressBar1.getGraphics());
    }

}        
    

//*****************************************************************************
//  La siguiente función realiza el cálculo del fractal tipo Spider
//*****************************************************************************
    
    public int counterSpider(int pos_x, int pos_y)
    {
        double r = (pos_x)*(maxR-minR)/max_x + minR;
        double i = (pos_y)*(maxI-minI)/max_y + minI;
        double modulo;  
        int iteraciones = 0;
        NroComplejo c = new NroComplejo(r,i);
        NroComplejo Zn = new NroComplejo(r,i);
        NroComplejo aux = new NroComplejo(0,0);
        modulo = Zn.getModulo();
        
        while ((iteraciones <256) && (modulo < 4))
        {
           aux = Zn.sqrt();
           Zn = NroComplejo.sumar(aux,c);
           c = NroComplejo.sumar(c.dividir(2),Zn);
           modulo =Zn.getModulo();
           iteraciones++;
        }
        return iteraciones;   
       
    }


    public void generarFractalSpider()
    {
        int dato;
        Color nuevo;
        b = new BufferedImage(max_x,max_y, BufferedImage.TYPE_INT_RGB); 
        jProgressBar1.setValue(0);
        jProgressBar1.setMinimum(0);
        jProgressBar1.setMaximum(max_x);
        for (int x = 0; x < max_x ; x++)
        { 
            for (int y = 0 ; y < max_y ; y++)
            {
                dato = counterSpider(x,y);
                mat_datos[x][y] = dato;
                b.setRGB(x,y,this.getColor(dato).getRGB());
            }
            jProgressBar1.setValue(x);
            jProgressBar1.update(jProgressBar1.getGraphics());
        }
    }

   
//*****************************************************************************
//  La siguiente función realiza el cálculo del fractal creado por mí
//*****************************************************************************    
    public int counterCarolina(int pos_x, int pos_y)
    {
        
        double r = (pos_x)*(maxR-minR)/max_x + minR;
        double i = (pos_y)*(maxI-minI)/max_y + minI;
        double modulo;  
        int iteraciones = 0;
        NroComplejo c = new NroComplejo(r,i);
        NroComplejo Z0 = new NroComplejo(r,i);
        NroComplejo Zn = new NroComplejo(r,i);
        NroComplejo aux = new NroComplejo(0,0);
        modulo = Zn.getModulo();
          double doub_aux;
        double aux_x;
        double aux_y;
        
        
        while ((iteraciones < 256)&&(modulo < 4))
        { 
             
             
             aux = Zn.sqrt().sqrt();
             c = NroComplejo.sumar(c.dividir(2),Zn);
             Zn = NroComplejo.sumar(aux,c);
             
             modulo = Zn.getModulo();
             iteraciones++;
        }
        return iteraciones;
    }
    
    
    
    public void generarFractalCarolina()
    {
        int dato;
        Color nuevo;
        b = new BufferedImage(max_x,max_y, BufferedImage.TYPE_INT_RGB); 
        jProgressBar1.setValue(0);
        jProgressBar1.setMinimum(0);
        jProgressBar1.setMaximum(max_x);
        for (int x = 0; x < max_x ; x++)
        {  
            for (int y = 0 ; y < max_y ; y++)
            {
                dato = counterCarolina(x,y);
                mat_datos[x][y] = dato;
                b.setRGB(x,y,this.getColor(dato).getRGB());
            }
           jProgressBar1.setValue(x);
           jProgressBar1.update(jProgressBar1.getGraphics());
        }
    }
    

//*********************************************************************************************
//  La siguiente función repinta el fractal con la nueva paleta y la matriz de datos calculados
//  para evitar el recalculo de valores en el repintado    
//********************************************************************************************* 
    public void repintarFractal()
    {
        int dato;
        for (int x = 0; x < max_x ; x++)
            for (int y = 0 ; y < max_y ; y++)
              {
                dato = mat_datos_actual[x][y];
                b.setRGB(x, y, this.getColor(dato).getRGB());
              }
        g.drawImage(b,0,0,null); 
    }
    

   
    
//*********************************************************************************************
//La siguiente función permite que la imagen pintada siga presente en el panel luego de
//que la ventana haya pasada a un segundo plano    
//*********************************************************************************************   
    @Override
    public void paint(Graphics g)
    {
      super.paint(g);
      g2 = jPanel1.getGraphics();
      g2.drawImage(b,0,0,null);
    }
    
    

    public void restaurarValoresOriginales() 
    {
        minR = -1.5;
        maxR = 0.5;
        minI = -1.0;
        maxI = 1.0;
    }
    
    
}//Fin Clase Principal
